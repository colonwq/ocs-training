= Red Hat Ceph Storage Stretch Cluster With Arbiter Deployment
:toc:
:toclevels: 4
:icons: font
:source-highlighter: pygments
:source-language: shell
:numbered:
// Activate experimental attribute for Keyboard Shortcut keys
:experimental:

== Overview

Red Hat Ceph Storage (RHCS) is an enterprise open-source platform that provides unified software-defined storage on standard, economical servers and disks. With block, object, and file storage combined into one platform, Red Hat Ceph Storage efficiently and automatically manages all your data, so you can focus on the applications and workloads that use it.


In this guide, we will explain how to properly set up a Red Hat Ceph Storage 5 cluster deployed on two different datacenters using the stretched mode functionality.


Also, RHCS provides other advanced characteristics like:

- Decouples software from hardware to run cost-effectively on industry-standard servers and disks.
- Scales flexibly and massively to support multiple petabyte deployments with consistent performance.
- Provides web-scale object storage for modern use cases, such as cloud infrastructure, media repository, and big data analytics.
- Combines the most stable version of Ceph with a storage management console, deployment tools, and support services.
- Object, block, and file storage.
- Compatibility with Amazon S3 object application programming interface (API), OpenStack Swift, NFS v4, or native API protocols.
- Block storage integrated with OpenStack, Linux, and KVM hypervisor.
- Validated with Apache Hadoop S3A filesystem client.
- Multi-site and disaster recovery options.
- Flexible storage policies.
- Data durability via erasure coding or replication.



In the diagram depicted below, we can see a graphical representation of the RHCS
architecture that will be used in this guide:


image::RHCS-stretch-cluster-arbiter.png[High Level Architecture RHCS stretch mode]

== RHCS stretch mode introduction

When the stretch mode is enabled, the OSDs will only take PGs active when they peer across datacenters, assuming both are alive with the following constraints:


* Pools will increase in size from the default 3 to 4, expecting two copies on each site.
* OSDs will only be allowed to connect to monitors in the same data center.
* New monitors will not join the cluster if they do not specify a location.


If all the OSDs and monitors from a datacenter become inaccessible at once, the surviving datacenter will enter a degraded stretch mode which implies:

* This will issue a warning, reduce the pool's `min_size` to 1, and allow the cluster to go active with data in the single remaining site.
* The pool `size` parameter is not changed, so you will also get warnings that the pools are too small.
* Although, the stretch mode flag will prevent the OSDs from creating extra copies in the remaining datacenter (so it will only keep two copies, as before).

When the missing data center comes back, the cluster will enter recovery stretch mode triggering the following actions:

* This changes the warning and allows peering, but still only requires OSDs from the datacenter, which was up the whole time.
* When all PGs are in a known state and are neither degraded nor incomplete, the cluster transitions back to the regular stretch mode where:

** The cluster ends the warning.
** Restores `min_size` to its starting value (2) and requires both sites to peer.
** Stops requiring the always-alive site when peering (so that you can failover to the other site, if necessary).



== Requirements for deploying Red Hat Ceph Storage stretch cluster with arbiter

Red Hat Ceph Storage (RHCS) is an enterprise open-source platform that provides unified software-defined storage on standard, economical servers and disks. With block, object, and file storage combined into one platform, Red Hat Ceph Storage efficiently and automatically manages all your data, so you can focus on the applications and workloads that use it.

This section provides a basic overview of the RHCS deployment. For more complex
deployment, refer to the link:https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/5[official documentation guide for RHCS 5.]

NOTE: Only Flash media is supported since it runs with `min_size=1` when degraded. Use stretch mode only with all-flash OSDs. Using all-flash OSDs minimizes the time needed to recover once connectivity is restored, thus minimizing the potential for data loss. Erasure coded pools cannot be used with stretch mode.

WARNING: Erasure coded pools cannot be used with stretch mode.

NOTE: Custom CRUSH rules providing two copies in each site (using a total of 4 copies) must be created when configuring the stretch mode in the Ceph cluster.


=== Hardware requirements

For information on minimum hardware requirements for deploying Red Hat Ceph
Storage, see
link:https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/5/html-single/hardware_guide/index#minimum-hardware-recommendations-for-containerized-ceph_hwMinimum[hardware recommendations for containerized Ceph.]


Physical server locations and Ceph component layout for Red Hat Ceph Storage cluster deployment. 

[cols=3,cols="^,^,^",options=header]
|===
|Node name|Datacenter|Ceph components
|ceph1|DC1| OSD+MON
|ceph2|DC1| OSD+MON+MGR
|ceph3|DC1| OSD+MDS+RGW
|ceph4|DC2| OSD+MON
|ceph5|DC2| OSD+MON+MGR
|ceph6|DC2| OSD+MDS+RGW
|ceph7|DC3| MON
|===

Software Details:

Use the latest software version of RHCS 5. See
link:https://access.redhat.com/articles/1548993[the knowledgebase article on
Red Hat Ceph Storage: Supported configurations.] 


=== Network Configurations

The recommended Red Hat Ceph Storage configuration are as follows:
You must have two separate networks, one public network and one private network.
You must have three different datacenters with L2 or L3 connectivity between all the nodes that form the Ceph cluster.
NOTE: You can use different subnets for each of the datacenters.

Here is an example of a basic network configuration that we have used in this guide:

* **DC1:** **Ceph public/private network:** 10.40.0.0/24
* **DC2:** **Ceph public/private network:** 10.40.0.0/24
* **DC3:** **Ceph public/private network:** 10.40.0.0/24

For more information on the required network environment, see
link:https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/5/html/configuration_guide/ceph-network-configuration[Ceph
network configuration.]


== Node Pre-Deployment Requirements

Before installing the RHCS Ceph cluster we need to perform the following steps in order to fulfil all the requirements needed:


=== Repositories and packages

. Register all the nodes to the Red Hat Network or Red Hat Satellite and subscribe to a valid pool:
+
[source,role="execute"]
....
subscription-manager register
subscription-manager subscribe --pool=8a8XXXXXX9e0
....
+
For example you can use `ceph1` as the deployment node. On ceph1, run the cephadm preflight ansible playbooks. For this you will need ansible 2.9 repos enabled in ceph1.
+
. Enable the following repositories:
+
* `rhel-8-for-x86_64-baseos-rpms`
* `rhel-8-for-x86_64-appstream-rpms`
* `rhceph-5-tools-for-rhel-8-x86_64-rpms`
* `ansible-2.9-for-rhel-8-x86_64-rpms` (only in the `ceph1` host)
+
. Enable the repos on all the servers that are going to be part of the RCHS cluster
+
[source,role="execute"]
....
subscription-manager repos --disable="*" --enable="rhel-8-for-x86_64-baseos-rpms" --enable="rhel-8-for-x86_64-appstream-rpms" --enable="rhceph-5-tools-for-rhel-8-x86_64-rpms"
....
+
. On the `ceph1` host also enable the `ansible-2.9-for-rhel-8-x86_64-rpms` repository:
+
[source,role="execute"]
....
subscription-manager repos --enable="ansible-2.9-for-rhel-8-x86_64-rpms"
....
+
. Update the system rpms to the latest version and reboot if needed:
+
[source,role="execute"]
....
dnf update -y
reboot
....
+
. In all our hosts we configure the hostname using the bare/short hostname.
+
[source,role="execute"]
....
hostnamectl set-hostname <short_name>
....
+
. Modify /etc/hosts file and add the fqdn entry to the 127.0.0.1 IP by setting the DOMAIN variable with our DNS domain name.
+
[source,role="execute"]
....
DOMAIN="bkgzv.sandbox762.opentlc.com"
cat <<EOF >/etc/hosts
127.0.0.1 $(hostname).${DOMAIN} $(hostname) localhost localhost.localdomain localhost4 localhost4.localdomain4
::1       $(hostname).${DOMAIN} $(hostname) localhost6 localhost6.localdomain6
EOF
....
+
. Verify the configuration for deploying Red Hat Ceph Storage with cephadm.
+
--
[source,role="execute"]
....
hostname
....

.Example output.
....
ceph1
....
--
+
. Check the long hostname with the fqdn using the hostname -f option.
+
--
[source,role="execute"]
....
hostname -f
....

.Example output.
....
ceph1.bkgzv.sandbox762.opentlc.com
....
--
+
. Install the `cephadm-ansible` RPM package:
+
--
[source,role="execute"]
....
sudo dnf install -y cephadm-ansible
....


IMPORTANT: To run the ansible playbooks, you must have ssh passwordless access to all the nodes that are configured to the Red Hat Ceph Storage cluster. Ensure that the configured user (for example, ec2-user) has root privileges to use the `sudo` command.
--
+
. Configure the ec2-user ssh config file to specify the user and id/key that can be used for connecting to the nodes via ssh:
+
--
[source,role="execute"]

....
cat <<EOF > ~/.ssh/config
Host ceph*
   User ec2-user
   IdentityFile ~/.ssh/ceph.pem
EOF
....
--
+
. Build our ansible inventory
+
--
[source,role="execute"]
....
cat <<EOF > /usr/share/cephadm-ansible/inventory
ceph1 
ceph2
ceph3
ceph4 
ceph5
ceph6
ceph7
[admin]
ceph1
EOF
....


NOTE: The `cephadm-ansible` pre-flight playbook deploys the RHCS admin keyring to all hosts belonging to the [admin] group at the following location /etc/ceph/ceph.client.admin.keyring.
--
+
. Verify ansible can access all of the nodes using the ping module before running the pre-flight playbook.
+
--
[source,role="execute"]
....
ansible -i /usr/share/cephadm-ansible/inventory -m ping all -b
....
.Example output.
....
ceph6 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
ceph4 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
ceph3 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
ceph2 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
ceph5 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
ceph1 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
ceph7 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
....


The preflight Ansible playbook configures the Ceph repository and prepares the storage cluster for bootstrapping. It also installs some prerequisites, such as podman, lvm2, chronyd, and cephadm. The default location for cephadm-ansible and cephadm-preflight.yml is /usr/share/cephadm-ansible.
--
+
. Run the following ansible playbook.
+
--
[source,role="execute"]
....
ansible-playbook -i /usr/share/cephadm-ansible/inventory /usr/share/cephadm-ansible/cephadm-preflight.yml --extra-vars "ceph_origin=rhcs"
....
--

== Cluster Bootstrapping with Cephadm

The cephadm utility installs and starts a Ceph Monitor daemon and a Ceph Manager daemon for a new Red Hat Ceph Storage cluster on the local node where the cephadm bootstrap command is run.

NOTE: For additional information on the bootstrapping process, see
link:https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/5/html/installation_guide/red-hat-ceph-storage-installation#bootstrapping-a-new-storage-cluster_install[Bootstrapping
a new storage cluster.]

`Procedure`

. Create json file to authenticate against the container registry using a json file as follows:
+
[source,role="execute"]
....
cat <<EOF > /root/registry.json
{
 "url":"registry.redhat.io",
 "username":"User",
 "password":"Pass"
}
EOF
....
+
. Configure Host Specs file.
+
--
You can use a service configuration file and the --apply-spec option to bootstrap the storage cluster and configure additional hosts and daemons. The configuration file is a .yaml file that contains the service type, placement, and designated nodes for services that you want to deploy.

[source,role="execute"]
....
cat <<EOF > /root/cluster-spec.yaml
service_type: host
addr: 10.0.40.78  —> <XXX.XXX.XXX.XXX>
hostname: ceph1   —>  <ceph-hostname-1>
---
service_type: host
addr: 10.0.40.35  —> <XXX.XXX.XXX.XXX>
hostname: ceph2  —>  <ceph-hostname-2>
---
service_type: host
addr: 10.0.40.24
hostname: ceph3
---
service_type: host
addr: 10.0.40.185
hostname: ceph4
---
service_type: host
addr: 10.0.40.88
hostname: ceph5
---
service_type: host
addr: 10.0.40.66
hostname: ceph6
---
service_type: host
addr: 10.0.40.221
hostname: ceph7
EOF
....
--
+
. Retrieve the IP for the NIC that has the RHCS public network configured from the bootstrap node. You can use the following example command after substituting the `10.0.40.0` with the subnet you have defined in your ceph public network.
+
--

[source,role="execute"]
....
ip a | grep 10.0.40
....

Example output:

....
10.0.40.78
....
--
+
. Run the `Cephadm` bootstrap command as the root user on the node that will be the initial Monitor node in the cluster. The `IP_ADDRESS` option is the IP address of the node that you are using to run the `cephadm bootstrap` command.
+
--
NOTE: If you have configured a different user than root for passwordless SSH access use the `--ssh-user=` flag with the cepadm bootstrap command


[source,role="execute"]
....
cephadm  bootstrap --ssh-user=ec2-user --mon-ip 10.0.40.78 --apply-spec /root/cluster-spec.yaml --registry-json /root/registry.json
....

IMPORTANT: If the local node uses fully-qualified domain names (FQDN), then add the `--allow-fqdn-hostname` option to cephadm bootstrap on the command line.

Once the bootstrap finishes, you will see the following output from the previous cephadm bootstrap command:


[source,role="execute"]
....
You can access the Ceph CLI with:

	sudo /usr/sbin/cephadm shell --fsid dd77f050-9afe-11ec-a56c-029f8148ea14 -c /etc/ceph/ceph.conf -k /etc/ceph/ceph.client.admin.keyring

Please consider enabling telemetry to help improve Ceph:

	ceph telemetry on

For more information see:

	https://docs.ceph.com/docs/pacific/mgr/telemetry/
....
--
+
. Verify the status of Red Hat Ceph Storage cluster deployment using the ceph cli client from ceph1:
+
--
[source,role="execute"]
....
ceph -s
....

.Example output.
....

  cluster:
    id:     dd77f050-9afe-11ec-a56c-029f8148ea14
    health: HEALTH_WARN
            OSD count 0 < osd_pool_default_size 3

  services:
    mon: 5 daemons, quorum ceph1,ceph4,ceph6,ceph3,ceph5 (age 2m)
    mgr: ceph1.laagvc(active, since 6m), standbys: ceph4.adlrnk
    osd: 0 osds: 0 up, 0 in

  data:
    pools:   0 pools, 0 pgs
    objects: 0 objects, 0 B
    usage:   0 B used, 0 B / 0 B avail
    pgs:
....

You now have 5 monitors running (this is now the default with cephadm deployments) if enough nodes are available. The cluster is in HEALTH_WARN state since no OSDs are deployed as yet.

NOTE: It is normal if you get a global recovery event while you don't have any osds configured.
--
+
. Check if all the services have started.
+
--

[source,role="execute"]
....
ceph orch ls
....

.Example output.
....

NAME           RUNNING  REFRESHED  AGE  PLACEMENT  
alertmanager       1/1  52s ago    6m   count:1    
crash              7/7  2m ago     7m   *          
grafana            1/1  52s ago    6m   count:1    
mgr                2/2  54s ago    7m   count:2    
mon                5/5  118s ago   7m   count:5    
node-exporter      7/7  2m ago     6m   *          
prometheus         1/1  52s ago    6m   count:1   
....

NOTE: It may take a while for all the services to start.
--
+
. Verify if all the nodes are part of the cephadm cluster.
+
--
[source,role="execute"]
....
ceph orch host ls
....

.Example output.
....
HOST   ADDR          LABELS  STATUS  
ceph1  10.0.40.78                   
ceph2  10.0.40.35                   
ceph3  10.0.40.24                   
ceph4  10.0.40.185                  
ceph5  10.0.40.88                   
ceph6  10.0.40.66                   
ceph7  10.0.40.221   
....

NOTE: We can run direct ceph commands from the host because we configured ceph1
in the cephadm-ansible inventory as part of the [admin] group, so the ceph
admin keys were copied to the host during the cephadm bootstrap process 
--

== Relocating the monitors and managers to an appropriate location

Red Hat Ceph Storage with `cephadm` deploys five monitors by default.  If they are not placed according to the topology architecture, use this procedure to correctly configure the ceph monitors to the appropriate datacenters.

. Check the current placement of the Ceph monitor services on the datacenters.
+
--
[source,role="execute"]
....
ceph orch ps | grep mon | awk '{print $1 " " $2}'
....

.Example output.
....
mon.ceph1 ceph1
mon.ceph2 ceph2
mon.ceph4 ceph4
mon.ceph5 ceph5
mon.ceph6 ceph6
....

You can see that there are 2 monitors on nodes in datacenter1, and three  monitors on nodes in datacenter2 but no monitors in datacenter3. Refer to the table in the Hardware requirements section to verify the layout of the ceph servers per datacenter.
--
+
. Move a monitor to the node `ceph7` located in our datacenter3 site.
+
--
[source,role="execute"]
....
ceph orch apply mon --placement="ceph1,ceph2,ceph4,ceph5,ceph7"
....

.Example output.
....
Scheduled mon update...
....
--
+
. Verify that the monitors are in the correct layout:
+
--
[source,role="execute"]
....
ceph orch ps | grep mon | awk '{print $1 " " $2}'
....

.Example output.
....
mon.ceph1 ceph1
mon.ceph2 ceph2
mon.ceph4 ceph4
mon.ceph5 ceph5
mon.ceph7 ceph7
....
--
+
. Check the current placement of the Ceph manager services on the datacenters.
+
--
....
ceph orch ps | grep mgr | awk '{print $1 " " $2}'
....

.Example output:
....
mgr.ceph1.ycgwy ceph1
mgr.ceph2.kremtt ceph2
....

You can see that there are 2 managers on nodes datacenter1, and no managers in datacenter2. Refer to the table in the Hardware requirements section to verify the layout of the ceph servers per datacenter.
--
+
. Move a manager to the node `ceph5` located in our datacenter2 site.
+
--
....
$ ceph orch apply mgr --placement="ceph2,ceph5"
....

.Example output:
....
Scheduled mgr update…
....
--
+
. Verify that the managers are in the correct layout:
+
--
....
$ ceph orch ps | grep mgr | awk '{print $1 " " $2}'
....

.Example output:
....
mgr.ceph2.ycgwyz ceph2
mgr.ceph5.kremtt ceph5
....
--

== Deploying Ceph services

This section provides examples of how you can deploy the following Ceph services:

* `Object Storage Devices (OSDs)`

* `Metadata services (MDS) required for CephFS`

* `Rados Gateway Services(RGW) required for object storage`

* `Rados Block Device (RBD) pool required for block storage`

IMPORTANT: it is mandatory to deploy the OSDs for the cluster to work.

`Procedure`

. Scan the hosts to check for available disks and to get the OSD layout. In this example, 6 OSDs will be created one per each ceph hosts where `ceph7` is the arbiter node which does not have any OSD's configured.
+
--
NOTE: Use the --all-available-devices option in the command if you wish to use all the free disks in the ceph nodes. Run this command twice; the first time to scan the nodes, and the second time to view the results. For details, see Management of services using the Ceph Orchestrator.

[source,role="execute"]
....

ceph orch apply osd --all-available-devices --dry-run

....

.Example output.

....
####################
SERVICESPEC PREVIEWS
####################
+---------+------+--------+-------------+
|SERVICE  |NAME  |ADD_TO  |REMOVE_FROM  |
+---------+------+--------+-------------+
+---------+------+--------+-------------+
################
OSDSPEC PREVIEWS
################
....

If we re-run the same command after a minute we can see that the devices on the
nodes have been discovered, and are available to be used as OSDs.

[source,role="execute"]
....
ceph orch apply osd --all-available-devices --dry-run
....

.Example output.
....
####################
SERVICESPEC PREVIEWS
####################
+---------+------+--------+-------------+
|SERVICE  |NAME  |ADD_TO  |REMOVE_FROM  |
+---------+------+--------+-------------+
+---------+------+--------+-------------+
################
OSDSPEC PREVIEWS
################
+---------+-----------------------+-------+-----------+----+-----+
|SERVICE  |NAME                   |HOST   |DATA       |DB  |WAL  |
+---------+-----------------------+-------+-----------+----+-----+
|osd      |all-available-devices  |ceph1  |/dev/xvdh  |-   |-    |
|osd      |all-available-devices  |ceph2  |/dev/xvdh  |-   |-    |
|osd      |all-available-devices  |ceph3  |/dev/xvdh  |-   |-    |
|osd      |all-available-devices  |ceph4  |/dev/xvdh  |-   |-    |
|osd      |all-available-devices  |ceph5  |/dev/xvdh  |-   |-    |
|osd      |all-available-devices  |ceph6  |/dev/xvdh  |-   |-    |
+---------+-----------------------+-------+-----------+----+-----+
....
--
+
. Run the command without –dry-run to create the OSD services
+
--

[source,role="execute"]
....
ceph orch apply osd --all-available-devices
....

.Example output.
....
Scheduled osd.all-available-devices update...
....
--
+
. Check the ceph osd crush map layout to ensure that each host has one OSD configured and its status is UP.
+
--
[source,role="execute"]
....
ceph osd tree
....

.Example output.
....
ID   CLASS  WEIGHT   TYPE NAME       STATUS  REWEIGHT  PRI-AFF
 -1         0.87900  root default
-11         0.14650      host ceph1
  2    ssd  0.14650          osd.2       up   1.00000  1.00000
 -3         0.14650      host ceph2
  3    ssd  0.14650          osd.3       up   1.00000  1.00000
-13         0.14650      host ceph3
  4    ssd  0.14650          osd.4       up   1.00000  1.00000
 -5         0.14650      host ceph4
  0    ssd  0.14650          osd.0       up   1.00000  1.00000
 -9         0.14650      host ceph5
  1    ssd  0.14650          osd.1       up   1.00000  1.00000
 -7         0.14650      host ceph6
  5    ssd  0.14650          osd.5       up   1.00000  1.00000
....
--
+
. Create and enable RBD a new block pool.
+
--

[source,role="execute"]
....
ceph osd pool create rbdpool 32 32
ceph osd pool application enable rbdpool rbd
....

NOTE: The number 32 at the end of the command is the number of PGs assigned to this pool, the number of PGs can vary depending on several factors like the number of OSDs in the cluster, expected % used of the pool, etc. You can use the following calculator to help you determine the number of PGs needed: https://access.redhat.com/labs/cephpgc/ 

5.Verify that the RBD pool has been created.

[source,role="execute"]
....
ceph osd lspools | grep rbdpool
....

.Example output.
....
3 rbdpool
....
--
+
. Using cephadm, deploy two new MDS daemons one in each datacenter. For more information, see link:https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/5/html/operations_guide/management-of-mds-service-using-the-ceph-orchestrator[Management of MDS service using the Ceph Orchestrator.]
+
--
 
In our example, we are using hosts `ceph3` and `ceph6`:


[source,role="execute"]
....
ceph orch apply mds cephfs --placement=ceph3,ceph6
....

.Example output.
....
Scheduled mds.cephfs update...
....
--
+
. Verify that MDS services are active.
+
--
[source,role="execute"]
....
ceph -s | grep mds
....

.Example output.

....
    mds: 1/1 daemons up, 1 standby
....
--
+
. Create the CephFS volume. For placements, use the same `hostname` as used in the previous command. 
+
--

[source,role="execute"]
....
ceph fs volume create cephfs --placement=ceph3,ceph6
....

NOTE: The ceph fs volume create command also creates the needed data and meta
CephFS pools. For more information, see
link:https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/5/html/file_system_guide/index[Configuring
and Mounting Ceph File Systems.]
--
+
. Check the Ceph status to verify how the MDS daemons have been deployed. Ensure that the state is active where `ceph6` is the primary MDS for this filesystem and ceph3 is the secondary MDS.
+
--
[source,role="execute"]
....
ceph fs status
....

.Example output.
....
cephfs - 0 clients
======
RANK  STATE           MDS             ACTIVITY     DNS    INOS   DIRS   CAPS
 0    active  cephfs.ceph6.ggjywj  Reqs:    0 /s    10     13     12      0
       POOL           TYPE     USED  AVAIL
cephfs.cephfs.meta  metadata  96.0k   284G
cephfs.cephfs.data    data       0    284G
    STANDBY MDS
cephfs.ceph3.ogcqkl
....
--
+
. Deploy the object services such that there is one RGW service per OSD datacenter.
Use the --placement argument as shown in below command. The initial number 2 in the example represents the number of RGW daemons to deploy, followed by the placement for the daemons specifying the hostname where the daemon must run. In this example, the hostname’s are ceph3 and ceph6.
+
--

[source,role="execute"]
....
ceph orch apply rgw objectgw  --port=8080 --placement="2 ceph3 ceph6"
....

.Example output.
....
Scheduled rgw.objectgw update...
....

To know more about RGW, see
link:https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/5/html-single/object_gateway_guide/index[The
Ceph Object Gateway.]
--
+
. Verify that RGW services are active.
+
--
[source,role="execute"]
....
ceph -s | grep rgw
....

.Example output.
....
rgw: 2 daemons active (2 hosts, 1 zones)
....
--



== Configuring Red Hat Ceph Storage stretch cluster

`Procedure`

. Check the current election strategy being used by the monitors with the ceph mon dump command. By default in a ceph cluster, the connectivity is set to classic.
+
--
[source,role="execute"]
....
$ ceph mon dump | grep election_strategy
....
.Example output.
....
dumped monmap epoch 9
election_strategy: 1
....
--
+
. Change the monitor election to connectivity.
+
--
[source,role="execute"]
....
ceph mon set election_strategy connectivity
....
--
+
. Run the previous ceph mon dump command again to verify the election_strategy value.
+
--
[source,role="execute"]
....
$ ceph mon dump | grep election_strategy
....
.Example output.
....
dumped monmap epoch 10
election_strategy: 3
....


NOTE: To know more about the different election strategies, see
link:https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/5/html/operations_guide/management-of-monitors-using-the-ceph-orchestrator#configuring-monitor-election-strategy_ops[Configuring
monitor election strategy.]
--
+
. Set the location for all our Ceph monitors:
+
--

[source,role="execute"]
....
ceph mon set_location ceph1 datacenter=DC1
ceph mon set_location ceph2 datacenter=DC1
ceph mon set_location ceph4 datacenter=DC2
ceph mon set_location ceph5 datacenter=DC2
ceph mon set_location ceph7 datacenter=DC3
....
--
+
. Verify that each monitor has its appropriate location.
+
[source,role="execute"]
....
ceph mon dump
....
+
.Example output.
....
epoch 17
fsid dd77f050-9afe-11ec-a56c-029f8148ea14
last_changed 2022-03-04T07:17:26.913330+0000
created 2022-03-03T14:33:22.957190+0000
min_mon_release 16 (pacific)
election_strategy: 3
0: [v2:10.0.143.78:3300/0,v1:10.0.143.78:6789/0] mon.ceph1; crush_location {datacenter=DC1}
1: [v2:10.0.155.185:3300/0,v1:10.0.155.185:6789/0] mon.ceph4; crush_location {datacenter=DC2}
2: [v2:10.0.139.88:3300/0,v1:10.0.139.88:6789/0] mon.ceph5; crush_location {datacenter=DC2}
3: [v2:10.0.150.221:3300/0,v1:10.0.150.221:6789/0] mon.ceph7; crush_location {datacenter=DC3}
4: [v2:10.0.155.35:3300/0,v1:10.0.155.35:6789/0] mon.ceph2; crush_location {datacenter=DC1}
....
+
. View the current CRUSH map
+
[source,role="execute"]
....
ceph osd tree
....
+
.Example output.
....

ID   CLASS  WEIGHT   TYPE NAME       STATUS  REWEIGHT  PRI-AFF
 -1         0.87900  root default
-11         0.14650      host ceph1
  2    ssd  0.14650          osd.2       up   1.00000  1.00000
 -3         0.14650      host ceph2
  3    ssd  0.14650          osd.3       up   1.00000  1.00000
-13         0.14650      host ceph3
  4    ssd  0.14650          osd.4       up   1.00000  1.00000
 -5         0.14650      host ceph4
  0    ssd  0.14650          osd.0       up   1.00000  1.00000
 -9         0.14650      host ceph5
  1    ssd  0.14650          osd.1       up   1.00000  1.00000
 -7         0.14650      host ceph6
  5    ssd  0.14650          osd.5       up   1.00000  1.00000
....
+
This default crush map indicates that the failure domain is at the host level and ceph has no understanding of what the infrastructure topology looks like.
+
. Use the following command to create the new buckets for `datacenter DC1` and `datacenter DC2`:
+
--

[source,role="execute"]
....
ceph osd crush add-bucket DC1 datacenter
ceph osd crush add-bucket DC2 datacenter
....
--
+
. Move the DC1 and DC2 datacenter buckets under the root default bucket.
+
[source,role="execute"]
....
ceph osd crush move DC1 root=default
ceph osd crush move DC2 root=default
....
+
. Move each of the hosts and their osds under each datacenter.
+
[source,role="execute"]
....
ceph osd crush move ceph1 datacenter=DC1
ceph osd crush move ceph2 datacenter=DC1
ceph osd crush move ceph3 datacenter=DC1
ceph osd crush move ceph4 datacenter=DC2
ceph osd crush move ceph5 datacenter=DC2
ceph osd crush move ceph6 datacenter=DC2
....
+
. Check the CRUSH map again with the ceph osd tree command to see how ceph is now mapped.
+
--
[source,role="execute"]
....
ceph osd tree
....

.Example output.
....
ID   CLASS  WEIGHT   TYPE NAME           STATUS  REWEIGHT  PRI-AFF
-1          0.87900  root default
-16         0.43950      datacenter DC1
-11         0.14650          host ceph1
  2    ssd  0.14650              osd.2       up   1.00000  1.00000
 -3         0.14650          host ceph2
  3    ssd  0.14650              osd.3       up   1.00000  1.00000
-13         0.14650          host ceph3
  4    ssd  0.14650              osd.4       up   1.00000  1.00000
-17         0.43950      datacenter DC2
 -5         0.14650          host ceph4
  0    ssd  0.14650              osd.0       up   1.00000  1.00000
 -9         0.14650          host ceph5
  1    ssd  0.14650              osd.1       up   1.00000  1.00000
 -7         0.14650          host ceph6
  5    ssd  0.14650              osd.5       up   1.00000  1.00000
....
--
+
. Create a CRUSH rule that makes use of this new topology by installing the ceph-base RPM package in order to use the crushtool command:
+
--
[source,role="execute"]
....
dnf -y install ceph-base
....

To know more about CRUSH ruleset, see
link:https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/5/html/architecture_guide/the-core-ceph-components#ceph-crush-ruleset_arch[Ceph
CRUSH ruleset.]
--
+
. Get the compiled CRUSH map from the cluster:
+
[source,role="execute"]
....
ceph osd getcrushmap > /etc/ceph/crushmap.bin
....
+
. Decompile the CRUSH map and convert it to a text file in order to be able to edit it:
+
[source,role="execute"]
....
crushtool -d /etc/ceph/crushmap.bin -o /etc/ceph/crushmap.txt
....
+
. Add the following rule to the CRUSH map by editing the text file /etc/ceph/crushmap.txt at the end of the file. 
+
--
[source,role="execute"]
....

vim /etc/ceph/crushmap.txt

...
rule stretch_rule {
        id 1
        type replicated
        min_size 1
        max_size 10
        step take DC1
        step chooseleaf firstn 2 type host
        step emit
        step take DC2
        step chooseleaf firstn 2 type host
        step emit
}

# end crush map
....

[NOTE]
====
The rule `id` has to be unique in our case we only have one more crush rule with
id 0 that is why we are using id 1, if your deployment has more rules created,
please use the next free id.
====

The CRUSH rule we have declared contains the following information:

* `Rule name`:
** Description: A unique whole name for identifying the rule.
** Value: `stretch_rule`
* `id`:
** Description: A unique whole number for identifying the rule.
** Value: `1`
* `type`:
** Description: Describes a rule for either a storage drive replicated or erasure-coded.
** Value: `replicated`
* `min_size`:
** Description: If a pool makes fewer replicas than this number, CRUSH will not select this rule.
** Value: `1`
* `max_size`:
** Description: If a pool makes more replicas than this number, CRUSH will not select this rule.
** Value: `10`
* `step take DC1`
** Description: Takes a bucket name (DC1), and begins iterating down the tree.
* `step chooseleaf firstn 2 type host`
** Description: Selects the number of buckets of the given type, in this case is two different hosts located in DC1.
* `step emit`
** Description: Outputs the current value and empties the stack. Typically used at the end of a rule, but may also be used to pick from different trees in the same rule.
* `step take DC2`
** Description: Takes a bucket name (DC2), and begins iterating down the tree.
* `step chooseleaf firstn 2 type host`
** Description: Selects the number of buckets of the given type, in this case, is two different hosts located in DC2.
* `step emit`
** Description: Outputs the current value and empties the stack. Typically used at the end of a rule, but may also be used to pick from different trees in the same rule.
--
+
. Compile the new CRUSH map from the file /etc/ceph/crushmap.txt and convert it to a binary file called /etc/ceph/crushmap2.bin:
+
[source,role="execute"]
....
crushtool -c /etc/ceph/crushmap.txt -o /etc/ceph/crushmap2.bin
....
+
. Inject the new crushmap we created back into the cluster:
+
--
[source,role="execute"]
....
ceph osd setcrushmap -i /etc/ceph/crushmap2.bin
....

.Example output.
....
17
....

NOTE: The number 17 is a counter and it will increase (18,19, and so on) depending on the changes you make to the crush map
--
+
. Verify that the stretched rule created is now available for use.
+
--
[source,role="execute"]
....
ceph osd crush rule ls
....

.Example output.
....
replicated_rule
stretch_rule
....
--
+
. Enable stretch cluster mode
+
--
[source,role="execute"]
....
ceph mon enable_stretch_mode ceph7 stretch_rule datacenter
....

In this example, `ceph7` is the arbiter node, `stretch_rule` is the crush rule we created in the previous step and `datacenter` is the dividing bucket.

$ Verify all our pools are using the `stretch_rule` CRUSH rule we have created in our Ceph cluster:

[source,role="execute"]
....
for pool in $(rados lspools);do echo -n "Pool: ${pool}; ";ceph osd pool get ${pool} crush_rule;done
....

.Example output.
....
Pool: device_health_metrics; crush_rule: stretch_rule
Pool: cephfs.cephfs.meta; crush_rule: stretch_rule
Pool: cephfs.cephfs.data; crush_rule: stretch_rule
Pool: .rgw.root; crush_rule: stretch_rule
Pool: default.rgw.log; crush_rule: stretch_rule
Pool: default.rgw.control; crush_rule: stretch_rule
Pool: default.rgw.meta; crush_rule: stretch_rule
Pool: rbdpool; crush_rule: stretch_rule
....

This indicates that a working Red Hat Ceph Storage stretched cluster with  arbiter mode is now available.
--

